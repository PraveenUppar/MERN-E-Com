Step 1: Define the Purpose of the Schema

- A category should have a name (e.g., "Electronics").
- A category might have a description.

Step 2: Write the Basic Schema

const categorySchema = mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
    },
    description: {
      type: String,
    },
  },
);

Step 3: Relate the Category Schema to Other Schemas

- Now that we have a Category schema, we need to connect it to our Product schema. 
- A single Category can have many Products. A Product, however, will only belong to one Category. This is a classic one-to-many relationship.

We will modify your existing productSchema to reference the Category model.

Before (your original schema):

// ...inside productSchema
category: {
  type: String,
  required: true,
},
// ...

After (the updated schema with a reference):

// ...inside productSchema
category: {
  type: mongoose.Schema.Types.ObjectId, // The type is ObjectId
  required: true,
  ref: "Category", // The ref property tells Mongoose which model to use for population
},
// ...

Explanation of the change:

- Instead of storing the category's name as a String, we now store its unique _id as an ObjectId. 
- This is a much more robust design because if you ever change the category's name, you don't have to update every product document.
The ref: "Category" property is crucial. It tells Mongoose that this _id is a reference to a document in the Category collection.

Step 4: How to Work with the Related Schemas

- how we would use this relationship in our code. This is where the power of Mongoose's populate() method comes in. 
- populate() automatically replaces the ObjectId reference with the actual document from the referenced collection.

